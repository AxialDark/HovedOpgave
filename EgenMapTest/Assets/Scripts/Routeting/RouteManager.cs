using UnityEngine;
using System.Collections.Generic;
using System.Collections;
using Assets.Helpers;

/// <summary>
/// Class to manage the route data generated by the Open Street Map API
/// This includes getting data from the Route class and uses to
/// creates object in the scene visualizing the route to the user
/// </summary>
public class RouteManager : MonoBehaviour {

    private Route route;
    private Transform mapParent;

    private static List<GameObject> routes = new List<GameObject>();
    private static List<GameObject> points = new List<GameObject>();
    public List<GameObject> debugPointList = new List<GameObject>();

    /// <summary>
    /// List of game objects generated, in between points, making out the entire route
    /// </summary>
    public static List<GameObject> Routes { get { return routes; } }
    /// <summary>
    /// List of points making out the route based on Via Points given to Open Street Map API
    /// </summary>
    public static List<GameObject> Points { get { return points; } }

    /// <summary>
    /// Unity build-in update method
    /// </summary>
    private void Update()
    {
#if UNITY_EDITOR
        debugPointList = points;
#endif
    }

    /// <summary>
    /// Initiate the generation of one route
    /// </summary>
    /// <param name="_myLatLong">The position of the user</param>
    /// <param name="_via">List of via points API uses to generate route</param>
    /// <param name="_settings">WorldMap settings</param>
    public void InitiateRouteGeneration(Vector2 _myLatLong, List<Vector2> _via, WorldMap.Settings _settings)
    {
        print("Initiating Generation");
        if (mapParent == null)
        {
            mapParent = GameObject.Find("Map").transform;
        }

        route = new Route().Initialize(_myLatLong, _via, _settings.detailLevel); //Make the route

        StartCoroutine(RouteToMap()); //Starts generating the route in scene based on data from the Route class
    }

    /// <summary>
    /// Creates the route in-scene
    /// </summary>
    /// <returns></returns>
    private IEnumerator RouteToMap()
    {
        while (!route.DataLoaded) //If the data the route is based on hasn't been loaded yet, return null
        {
            yield return null;
        }

        print("Creating route on map");

        //Runs through all the route coordinates to create points and route objects in between these points
        //i starts at 1 meaning, that the "current" index for route is (i - 1) and i is the distination,
        //because it's zero-indexed
        for (int i = 1; i < route.RouteInMercCoords.Count; i++)
        {
            GameObject routePlane = GameObject.CreatePrimitive(PrimitiveType.Plane); //Create plane game object

            float distance = Vector2.Distance(route.RouteInMercCoords[i - 1], route.RouteInMercCoords[i]); //Calculates distance between current point and the next

            Vector2 diff = new Vector2(route.RouteInMercCoords[i].x - route.RouteInMercCoords[i - 1].x, 
                route.RouteInMercCoords[i].y - route.RouteInMercCoords[i - 1].y); //Gets the vector in between the current point vector and the distination point vector

            Vector3 middlePoint = new Vector3((diff.x / 2) + route.RouteInMercCoords[i - 1].x, 
                0.5f, (diff.y / 2) + route.RouteInMercCoords[i - 1].y);//Gets the point exactly between the current point and the distination point

            //Creates route object
            routePlane.transform.SetParent(mapParent);
            routePlane.transform.position = middlePoint;
            routePlane.name = "Route between: " + i + " - " + (i + 1);            
            routePlane.transform.localScale = new Vector3(0.25f, 0, distance / 10);
            routePlane.GetComponent<Renderer>().material = Resources.Load<Material>("DebugRoute");
            routePlane.transform.LookAt(new Vector3(route.RouteInMercCoords[i].x, 0.5f, route.RouteInMercCoords[i].y));
            routes.Add(routePlane);

            //Create point gameobject
            GameObject point = GameObject.CreatePrimitive(PrimitiveType.Sphere);
            point.name = "Route point " + i;
            point.transform.SetParent(mapParent);
            point.transform.position = new Vector3(route.RouteInMercCoords[i - 1].x, 10, route.RouteInMercCoords[i - 1].y);
            point.transform.localScale = new Vector3(10, 10, 10);
            point.AddComponent<Collider>();
            point.GetComponent<Collider>().isTrigger = true;
            points.Add(point);
        }
        routes[0].GetComponent<Renderer>().material = Resources.Load<Material>("DebugRouteHighlight"); //Shows the first route is highlighted

        print("Distance: " + route.Distance);
    }

    /// <summary>
    /// Handles the completion of a route
    /// </summary>
    private void EndRoute()
    {
        //Clears the route from game
        foreach (GameObject routeOrPoint in routes)
        {
            Destroy(routeOrPoint);
        }

        routes.Clear();
    }

    /// <summary>
    /// Updates route by highighting the next route
    /// </summary>
    public static void UpdateRouteForUser()
    {
        points[0].gameObject.SetActive(false);
        points.RemoveAt(0);
        routes[0].gameObject.SetActive(false);
        routes.RemoveAt(0);
        routes[0].GetComponent<Renderer>().material = Resources.Load<Material>("DebugRouteHighlight");
    }
}
